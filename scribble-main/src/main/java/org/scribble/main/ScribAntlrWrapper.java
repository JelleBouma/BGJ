/**
 * Copyright 2008 The Scribble Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package org.scribble.main;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.stream.Collectors;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.Lexer;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.tree.CommonErrorNode;
import org.antlr.runtime.tree.CommonTree;
import org.scribble.ast.Module;
import org.scribble.del.DelDecorator;
import org.scribble.del.DelDecoratorImpl;
import org.scribble.main.resource.Resource;
import org.scribble.parser.antlr.ScribbleLexer;
import org.scribble.parser.antlr.ScribbleParser;
import org.scribble.parser.scribble.ScribTreeAdaptor;
import org.scribble.util.ScribParserException;

// Resource -> ANTLR CommonTree -- parses Resources into ANTLR CommonTrees
// Wraps the ScribbleLexer and ScribbleParser generated by ANTLR from Scribble.g
public class ScribAntlrWrapper
{
	private final DelDecorator df = new DelDecoratorImpl();
	
	public ScribAntlrWrapper()
	{

	}
	
	// Scribble extensions should override newScribbleLexer/Parser as appropriate
	// A fresh Lexer/Parser is needed by each call to parse 
	protected Lexer newScribbleLexer(ANTLRStringStream ss)
	{
		return new ScribbleLexer(ss);
	}

	// Scribble extensions should override newScribbleLexer/Parser as appropriate
	// ScribbleParser: a Parser that has a top-level "module" method
	// (And has "setTreeAdaptor")
	protected ScribbleParser newScribbleParser(CommonTokenStream ts)
	{
		return new ScribbleParser(ts);
	}

	// Parse a Resource into a (del decorated) Module
	public Module parse(Resource res) throws ScribParserException
	{
		try
		{
			String input = ScribAntlrWrapper.readInput(res);
			Lexer lex = newScribbleLexer(new ANTLRStringStream(input));
			Module mod = runScribbleParser(new CommonTokenStream(lex));
			this.df.decorate(mod);
			return mod;
		}
		catch (IOException e)
		{
			throw new ScribParserException(e);
		}
	}

	protected Module runScribbleParser(CommonTokenStream ts)
			throws ScribParserException
	{
		try
		{
			ScribbleParser p = newScribbleParser(ts);
			p.setTreeAdaptor(new ScribTreeAdaptor());
			return (Module) p.module().getTree();
					// Cast, because no convenient way to expose an interface for all (Scribble)Parsers with top-level "module" method?
		}
		catch (RecognitionException e)
		{
			throw new ScribParserException(e);
		}
	}

	// CHECKME: should this be used somewhere?
	public static void checkForAntlrErrors(CommonTree t)
	{
		if (t.getChildCount() > 0)  // getChildren returns null instead of empty list 
		{
			List<CommonErrorNode> errors = ((List<?>) t.getChildren()).stream()
					.filter(c -> (c instanceof CommonErrorNode))
					.map(c -> (CommonErrorNode) c)
					.collect(Collectors.toList());
			if (errors.size() > 0)  // Antlr prints errors to System.err by default, but then attempts to carry on
						// Should never get here now, Antlr displayRecognitionError overridden to force exit: Antlr error recovery means not all errors produce CommonErrorNode
			{
				// TODO: improve feedback message
				System.err
						.println("[ScribParser] Aborting due to parsing errors: " + errors);
				System.exit(1);
			}
		}
	}
	
	protected static String readInput(Resource res) throws IOException
	{
		return new String(ScribAntlrWrapper.readResource(res));
	}

	protected static byte[] readResource(Resource res) throws IOException
	{
		try (InputStream is = res.getInputStream())
		{
			byte[] bs = new byte[is.available()];
			is.read(bs);
			return bs;
		}
	}
}
